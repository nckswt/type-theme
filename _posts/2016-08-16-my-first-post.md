---
layout: post
title: Setting up an Embedded Linux Development Environment
---

# Introduction

I'm about to start working on a new project, and thought it was time to really give my development environment a once-over. I'll be writing C++ and Python code to be executed onboard a small robotic platform.

# Philosophical Points

The following are a few personal philosophical underpinnings that are completely biased. These drive my search for a solid development environment. Many of them contradict one-another (*Do I contradict myself? / Very well then, I contradict myself / (I am large, I contain multitudes) - Walt Whitman, Song of Myself).

## 1. If it doesn't work for me, it doesn't work
Whatever tools and setup I'm using, if I don't feel comfortable with them, I have two primary options: I can develop that comfortable feel for them, or I can simply not use them. For instance, I hate Eclipse. It was the first real IDE I've ever used, and really opened my eyes for what I can do with computers, but, even a decade ago it felt a decade behind. I've grown up using Apple products since I was 5, and I've gotten used to computers as more than just tools, but something beautiful with which to interact. If I'm going to spend most of my life staring at a computer, I want that computer to reflect some notion of aesthetic. Same idea for that computer's software.

I need a development environment that matches my notions of aesthetic and user-friendliness. You should examine your own personal philosophies: do you not care about how your interface looks, just so long as it works? Do you want the most bare-bones environment possible? Do you want to use whatever's familiar? These are all valid concerns, but nothing that the internet will answer for you.

## 2. "The right tool for the right job" is bullshit.
The notion that you need to use the right tool for the right job is a load of crap. Ideally, it's perfect -- of course you want to follow that rule; however, given the amount of tools available for any job, can you really justify that you're using the right tool? Are you going to do an exhaustive search over all possible text editors before writing a single line of code? The rule that makes more sense to me is the following: "Try something. If it doesn't work, try something better."

The focus on tool-driven development can hinder development itself. It's often better to start nailing with a rusty hammer than to spend all your energy searching for a nicer hammer.

## 3.


## 4. Know when (and when not) to use abstraction
One of the best parts of code is its ability to be re-used.
